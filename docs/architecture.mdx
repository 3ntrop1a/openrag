---
title: 'Architecture'
description: 'Architecture d√©taill√©e du syst√®me OpenRAG'
---

# Architecture OpenRAG

OpenRAG impl√©mente une architecture microservices modulaire et scalable bas√©e sur le pattern RAG (Retrieval-Augmented Generation).

## Vue d'ensemble

```mermaid
graph TB
    subgraph "Interface Utilisateur"
        User[üë§ Utilisateur]
    end
    
    subgraph "API Layer"
        API[API Gateway<br/>FastAPI:8000]
    end
    
    subgraph "Orchestration Layer"
        Orch[Orchestrateur<br/>:8001]
    end
    
    subgraph "Processing Layer"
        Embed[Embedding Service<br/>:8002]
    end
    
    subgraph "Storage Layer"
        MinIO[MinIO<br/>Object Storage]
        Qdrant[Qdrant<br/>Vector DB]
        Postgres[(PostgreSQL<br/>Metadata DB)]
    end
    
    subgraph "AI Layer"
        Ollama[Ollama<br/>LLM Server]
    end
    
    subgraph "Infrastructure"
        Redis[(Redis<br/>Cache & Queue)]
    end
    
    User --> API
    API --> Orch
    Orch --> Embed
    Orch --> MinIO
    Orch --> Qdrant
    Orch --> Postgres
    Orch --> Ollama
    Orch --> Redis
    Embed --> Redis
```

## Composants principaux

### 1. API Gateway (Port 8000)

Point d'entr√©e REST pour toutes les interactions utilisateur.

**Responsabilit√©s :**
- Authentification et autorisation (√† venir)
- Validation des requ√™tes
- Routing vers l'orchestrateur
- Rate limiting
- Documentation API (Swagger)

**Technologies :**
- FastAPI
- Uvicorn (ASGI server)
- Pydantic (validation)

### 2. Orchestrateur (Port 8001)

C≈ìur du syst√®me qui coordonne le workflow RAG complet.

**Responsabilit√©s :**
- Coordination du pipeline d'ingestion de documents
- Gestion du workflow de requ√™tes
- Communication inter-services
- Gestion des jobs asynchrones
- Monitoring des processus

**Workflow d'ingestion de document :**

```mermaid
sequenceDiagram
    participant Client
    participant API
    participant Orch as Orchestrateur
    participant MinIO
    participant DB as PostgreSQL
    participant Embed as Embedding Service
    participant Qdrant

    Client->>API: Upload document
    API->>Orch: Forward file
    Orch->>MinIO: Store file
    Orch->>DB: Save metadata
    Orch->>Orch: Extract & chunk text
    
    loop For each chunk
        Orch->>Embed: Generate embedding
        Embed-->>Orch: Return vector
        Orch->>Qdrant: Index vector
        Orch->>DB: Save chunk metadata
    end
    
    Orch->>DB: Update status: processed
    Orch-->>API: Return job_id
    API-->>Client: Success response
```

**Workflow de requ√™te RAG :**

```mermaid
sequenceDiagram
    participant Client
    participant API
    participant Orch as Orchestrateur
    participant Embed as Embedding Service
    participant Qdrant
    participant DB as PostgreSQL
    participant LLM as Ollama

    Client->>API: POST /query
    API->>Orch: Process query
    Orch->>Embed: Embed query
    Embed-->>Orch: Query vector
    Orch->>Qdrant: Search similar vectors
    Qdrant-->>Orch: Top K results
    Orch->>DB: Get chunk contents
    DB-->>Orch: Chunk data
    Orch->>LLM: Generate answer with context
    LLM-->>Orch: Generated answer
    Orch->>DB: Save query log
    Orch-->>API: Response with answer & sources
    API-->>Client: JSON response
```

### 3. Embedding Service (Port 8002)

Service sp√©cialis√© pour la g√©n√©ration d'embeddings vectoriels.

**Responsabilit√©s :**
- G√©n√©ration d'embeddings pour les textes
- Support du traitement par batch
- Optimisation des performances (GPU si disponible)

**Mod√®les support√©s :**
- `sentence-transformers/all-MiniLM-L6-v2` (d√©faut, 384 dimensions)
- `sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2` (multilingue)
- `sentence-transformers/all-mpnet-base-v2` (meilleur qualit√©)
- Mod√®les personnalis√©s compatibles sentence-transformers

**Configuration :**
```env
EMBEDDING_MODEL=sentence-transformers/all-MiniLM-L6-v2
EMBEDDING_DEVICE=cpu  # ou cuda
EMBEDDING_BATCH_SIZE=32
```

### 4. MinIO (Ports 9000, 9001)

Stockage d'objets S3-compatible pour les documents originaux.

**Responsabilit√©s :**
- Stockage persistant des fichiers upload√©s
- Versioning des documents
- Gestion des buckets

**Structure de stockage :**
```
documents/
‚îú‚îÄ‚îÄ {document_id_1}/
‚îÇ   ‚îî‚îÄ‚îÄ filename.pdf
‚îú‚îÄ‚îÄ {document_id_2}/
‚îÇ   ‚îî‚îÄ‚îÄ rapport.docx
‚îî‚îÄ‚îÄ ...
```

**Acc√®s :**
- API S3 : `http://localhost:9000`
- Console Web : `http://localhost:9001`

### 5. Qdrant (Ports 6333, 6334)

Base de donn√©es vectorielle pour la recherche s√©mantique.

**Responsabilit√©s :**
- Indexation des vecteurs d'embeddings
- Recherche de similarit√© (HNSW algorithm)
- Filtrage par m√©tadonn√©es
- Clustering et optimisation

**Collections :**
- `documents_embeddings` : Collection par d√©faut
- Collections personnalis√©es par cas d'usage

**Configuration :**
```yaml
vectors:
  size: 384  # selon le mod√®le d'embedding
  distance: Cosine  # ou Dot, Euclidean
```

**Payload structure :**
```json
{
  "document_id": "uuid",
  "chunk_index": 0,
  "content": "texte du chunk",
  "metadata": {
    "source_file": "document.pdf",
    "page": 1
  }
}
```

### 6. PostgreSQL (Port 5432)

Base de donn√©es relationnelle pour les m√©tadonn√©es.

**Sch√©ma principal :**

<CodeGroup>

```sql Documents
CREATE TABLE documents (
    id UUID PRIMARY KEY,
    filename VARCHAR(255),
    file_type VARCHAR(50),
    file_size BIGINT,
    minio_object_key VARCHAR(500),
    status VARCHAR(50),
    upload_date TIMESTAMP,
    processed_date TIMESTAMP,
    metadata JSONB,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

```sql Chunks
CREATE TABLE document_chunks (
    id UUID PRIMARY KEY,
    document_id UUID REFERENCES documents(id),
    chunk_index INTEGER,
    content TEXT,
    vector_id VARCHAR(255),  -- ID dans Qdrant
    metadata JSONB,
    created_at TIMESTAMP
);
```

```sql Queries
CREATE TABLE queries (
    id UUID PRIMARY KEY,
    user_id VARCHAR(255),
    query_text TEXT,
    response_text TEXT,
    sources JSONB,
    execution_time_ms INTEGER,
    created_at TIMESTAMP,
    metadata JSONB
);
```

```sql Collections
CREATE TABLE collections (
    id UUID PRIMARY KEY,
    name VARCHAR(255) UNIQUE,
    description TEXT,
    created_at TIMESTAMP,
    metadata JSONB
);
```

</CodeGroup>

### 7. Ollama (Port 11434)

Serveur LLM local pour la g√©n√©ration de r√©ponses.

**Responsabilit√©s :**
- Ex√©cution des mod√®les de langage
- G√©n√©ration de r√©ponses contextualis√©es
- Gestion du cache de mod√®les

**Mod√®les recommand√©s :**

<CardGroup cols={2}>
  <Card title="Llama 3.1 8B" icon="llama">
    Meilleur rapport qualit√©/performance
  </Card>
  <Card title="Phi-3 Mini" icon="microsoft">
    Mod√®le l√©ger et rapide
  </Card>
  <Card title="Gemma 7B" icon="google">
    Excellent pour les t√¢ches analytiques
  </Card>
  <Card title="Mistral 7B" icon="robot">
    Tr√®s bon en fran√ßais
  </Card>
</CardGroup>

**Alternative avec API Cloud :**
```env
LLM_PROVIDER=openai
LLM_MODEL=gpt-4-turbo
OPENAI_API_KEY=sk-...
```

### 8. Redis (Port 6379)

Cache distribu√© et file de messages.

**Usages :**
- Cache des embeddings r√©cents
- File de t√¢ches asynchrones (avec Celery)
- Session management
- Rate limiting

## Flux de donn√©es

### Ingestion de document

1. **Upload** : Document envoy√© via API
2. **Stockage** : Sauvegarde dans MinIO
3. **Extraction** : Extraction du texte selon le format
4. **Chunking** : D√©coupage en morceaux de ~512 tokens
5. **Embedding** : G√©n√©ration de vecteurs pour chaque chunk
6. **Indexation** : Stockage des vecteurs dans Qdrant
7. **M√©tadonn√©es** : Enregistrement en PostgreSQL

### Traitement de requ√™te

1. **Requ√™te** : Question de l'utilisateur
2. **Embedding** : Vectorisation de la requ√™te
3. **Recherche** : Top-K recherche dans Qdrant (cosine similarity)
4. **R√©cup√©ration** : Obtention des contenus des chunks
5. **Contexte** : Assemblage du contexte pour le LLM
6. **G√©n√©ration** : LLM g√©n√®re une r√©ponse
7. **Logging** : Enregistrement de la requ√™te et r√©ponse

## Scalabilit√©

### Scaling horizontal

Chaque service peut √™tre scal√© ind√©pendamment :

```yaml
docker-compose.yml:
  orchestrator:
    deploy:
      replicas: 3
```

### Optimisations

<AccordionGroup>
  <Accordion title="Embedding Service">
    - Utiliser GPU pour les embeddings (10-50x plus rapide)
    - Augmenter le batch size
    - Cacher les embeddings fr√©quents dans Redis
  </Accordion>
  
  <Accordion title="Qdrant">
    - Activer HNSW index optimization
    - Sharding pour grandes collections (>10M vectors)
    - Quantization pour r√©duire l'empreinte m√©moire
  </Accordion>
  
  <Accordion title="Ollama">
    - Utiliser plusieurs GPUs
    - Activer le parall√©lisme de requ√™tes
    - Optimiser les param√®tres du mod√®le
  </Accordion>
  
  <Accordion title="PostgreSQL">
    - Indexer les colonnes fr√©quemment requ√™t√©es
    - Partitioning pour grandes tables
    - Connection pooling (PgBouncer)
  </Accordion>
</AccordionGroup>

## S√©curit√©

<Warning>
  Configuration de s√©curit√© de base - √Ä renforcer pour la production !
</Warning>

### √Ä impl√©menter pour la production

- ‚úÖ **Authentication** : JWT tokens, OAuth2
- ‚úÖ **Authorization** : RBAC (Role-Based Access Control)
- ‚úÖ **HTTPS/TLS** : Chiffrement des communications
- ‚úÖ **Secrets Management** : Vault, AWS Secrets Manager
- ‚úÖ **Network Policies** : Isolation des services
- ‚úÖ **Input Validation** : Protection contre les injections
- ‚úÖ **Rate Limiting** : Protection DDoS
- ‚úÖ **Audit Logging** : Tra√ßabilit√© des op√©rations

## Monitoring

### M√©triques importantes

- **API** : Requ√™tes/sec, latence, taux d'erreur
- **Orchestrateur** : Jobs en cours, dur√©e moyenne
- **Qdrant** : Temps de recherche, taille des collections
- **PostgreSQL** : Connexions, requ√™tes lentes
- **Ollama** : Tokens/sec, utilisation GPU/CPU

### Stack de monitoring (optionnel)

```bash
docker-compose --profile monitoring up -d
```

- **Prometheus** : Collecte de m√©triques
- **Grafana** : Visualisation (dashboards pr√©-configur√©s)
- **Loki** : Agr√©gation de logs

## Prochaines √©tapes

<CardGroup cols={2}>
  <Card
    title="Guide d'installation"
    icon="download"
    href="/installation/docker-setup"
  >
    Installation compl√®te √©tape par √©tape
  </Card>
  <Card
    title="Configuration"
    icon="sliders"
    href="/installation/configuration"
  >
    Param√©trage avanc√© des composants
  </Card>
  <Card
    title="D√©ploiement production"
    icon="server"
    href="/deployment/production"
  >
    Best practices pour la production
  </Card>
  <Card
    title="API Reference"
    icon="code"
    href="/api-reference"
  >
    Documentation de l'API
  </Card>
</CardGroup>
